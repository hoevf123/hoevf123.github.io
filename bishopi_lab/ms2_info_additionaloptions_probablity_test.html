<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <title>비숍이 실험실</title>
    <link rel="stylesheet" href="common.css">
    <script src="w3-include-html.js"></script>
    <script src="nav-header.js"></script>
</head>

<body>
    <div w3-include-html="nav-header.html"></div>
    <section>
        <div class="div-content">
            <h1>메이플스토리2 방어구(모자, 상의, 하의) 추가 옵션 검증</h1>
            <p>이 페이지는 메이플스토리2 방어구 옵션을 테스트하기 위한 페이지입니다.</p>
            <p>※ 현재 이 페이지를 통해 나오는 결과값은  <b>추정치</b> 입니다. 실제 메이플스토리2에서 나오는 등장 확률은 아래 링크를 확인해 주십시오. ※</p>
            <span><a href="https://maplestory2.nexon.com/Probability/ItemOption">[메이플스토리2 - 가이드 - 확률공개 - 아이템 추가옵션 변경]</a></span>
            <p>(표본에 의한 확률값은 실제로 장비를 분해한 결과를 바탕으로 넣은 임의의 수치이며, 장비의 옵션 정렬 순서는 벨붕 님의 도움을 받았습니다.)</p>
            <br/>
            <br/>

            <h3>메이플스토리2 장비의 추가 옵션 선정 정의</h3>
            <p>(아래의 글이 이해가지 않는다면, 아래의 링크에 있는 그림 설명을 보세요)</p>
            <span><a href="https://maplestory2.nexon.com/Board/Free/DetailView?sn=186539">[링크]</a></span>
            <ol>
                <li><p>각각의 옵션에는 선별 확률 가중치가 적용되어 있습니다. (예: 보스 공격 시 대미지 증가 : 7)</p></li>
                <li><p>하나의 옵션이 옵션 목록에서 선정되면, 선별된 옵션은 다음 옵션 선정에서 제외됩니다.</p></li>
                <li>
                    <p>일부 옵션 그룹 중에서 최대 n개의 옵션이 선별되면, 그 그룹의 모든 옵션을 이후의 모든 선정에서 제외합니다.</p>
                    <p>(예 : STR 선정 시 DEX, INT, LUK 등의 모든 공격 관련 옵션이 다음 옵션 선정에서 제외됨)</p>
                </li>
                <li>
                    <p>위의 세 규칙에 따라 장비에 있는 추가 옵션을 차례로 뽑은 뒤, 정렬 우선순위에 따라 보기 좋게 정렬하여 최종적인 장비의 추가 옵션이 정해집니다.</p>
                    <p>단, 편의 상 다음 뽑기에서 남아있는 추가옵션 목록과 추가옵션의 가중치 값은 변하지 않는다고 가정하기 때문에, 다음 뽑기에서의 특정 옵션의 선택 확률이 높아지거나 낮아집니다.</p>
                </li>
                <li>
                    <p>고정권을 사용한 상태에서 옵션 변경을 할 경우에는 고정권을 사용한 옵션을 제외한 나머지 옵션을 뽑는 시행을 진행합니다.</p>
                    <p>(즉, 방어구 기준 스텟 관련 옵션을 고정한 경우에는 스텟 관련 옵션을 제외한 나머지 옵션들만 재선정되며, 고정권을 사용한 실제 결과의 옵션에 따라 고정된 추가옵션의 위치는 변경될 수 있습니다.</p>
                </li>
            </ol>
            <br/>
            <h3>파이어 프리즘 모자 추가 옵션 선정 예시(추정)</h3>
            <p>(단, [] 안의 수치는 가중치)</p>
            <ol>
                <li>
                    <p>1옵션 선정 (명중[4], 크리티컬 회피[8], 근접 대미지 감소[10], 보스 공격 시 대미지 증가 [4], 신성 대미지 감소 [10]) 가중치 총 합계 : 36</p>
                    <p>선정 값 : 0.2 * 36 =  7.2, 크리티컬 회피 옵션 선정</p>
                </li>
                <li>
                    <p>2옵션 선정 (명중[4], 근접 대미지 감소[10], 보스 공격 시 대미지 증가 [4], 신성 대미지 감소 [10]) 가중치 총 합계 : 28</p>
                    <p>선정 값 : 0.9 * 28 =  25.2, 신성 대미지 감소 옵션 선정</p>
                </li>
                <li>
                    <p>3옵션 선정 (명중[4], 근접 대미지 감소[10], 보스 공격 시 대미지 증가 [4]) 가중치 총 합계 : 18</p>
                    <p>선정 값 : 0.2 * 18 =  3.6, 명중 옵션 선정</p>
                    <p>선정된 추가 옵션 중 1회 이상 선정 시 옵션 그룹에 포함된 모든 옵션 구성 제거(명중, 보스 공격 시 대미지 증가)</p>
                </li>
                <li>
                    <p>남아있는 추가 옵션 구성(근접 대미지 감소[10]) 가중치 총 합계 : 10</p>
                    <p>최종 선정 옵션 : "크리티컬 회피", "신성 대미지 감소", "명중"</p>
                </li>
                <li>
                    <p>옵션의 표시 우선 순위에 따라 최종 옵션 표시.</p>
                    <p>(옵션 정렬 순서는 아래의 추가 옵션 표시 우선순위를 확인해주세요)</p>
                    <h3>추가 옵션</h3>
                    <ol>
                        <li><p>크리티컬 회피</p></li>
                        <li><p>명중</p></li>
                        <li><p>신성 대미지 감소</p></li>
                    </ol>
                </li>
            </ol>
            
            <br/>
            <br/>
            <br/>
            <h3>추가 옵션 정렬 우선순위(3줄옵션 모자, 상의, 하의)</h3>
            <p>※ 숫자 밑에 아무런 숫자가 없는 추가 옵션은 동일 우선순위이며, 동일 우선순위인 옵션들은 (동일 그룹 내 옵션들 중에서) 먼저 선별된 옵션이 표시됩니다 ※</p>
            <ol class="ms2-additionaloptions-sort"></ol>
            <br/>
            <br/>
            <h3>최대 1개만 나오는 추가 옵션(모자, 상의, 하의)</h3>
            <ol class="ms2-additionaloptions-onlyone-sort"></ol>
            <br/>
            <br/>
            <h3>※ 테스트 가능한 수치를 변경하고 싶으신 분은, 소스 코드를 직접 고쳐서 다시 실행시켜야 합니다. ※</h3>
            <br/>
            <br/>
            <h3>테스트 결과</h3>
            <h4>옵션 통계</h4>
            <div class="ms2-additionaloptions-probablity-test-statistics-result"> </div>
            <br/>
            <h4>테스트를 통해 나온 추가 옵션 결과값</h4>
            <div class="ms2-additionaloptions-probablity-test-result"></div>
            <br/>
            <br/>
            




            <!-- 옵션 테스터 자바스크립트 소스코드 -->
            <script type="text/javascript">
                const ol_additionaloptions_className="ms2-additionaloptions-sort";
                const ol_additionaloptions_onlyone_className="ms2-additionaloptions-onlyone-sort";
                const div_addtioaloptions_probablity_result_className="ms2-additionaloptions-probablity-test-result";
                let [dom_ol_additionaloptions, 
                    dom_ol_additionaloptions_onlyone, 
                    dom_div_additionaloption_probablity_test_result
                ] = [
                    ol_additionaloptions_className, 
                    ol_additionaloptions_onlyone_className, 
                    div_addtioaloptions_probablity_result_className
                ].reduce((a,c)=>{
                    a.push(Array.from(document.getElementsByClassName(c)));
                    return a;
                },[]);
                class AdditionalOption{
                    constructor(optionName, sortOrder, revealProbablity=1){
                        this.name = optionName;
                        this.order = sortOrder;
                        this.probablity = revealProbablity;
                    }
                }
                let additionOptions=[
                    ["STR",1 , 10],
                    ["DEX",2 , 7],
                    ["INT",3 , 7],
                    ["크리티컬 회피",3 , 18],
                    ["LUK",4, 7],
                    ["HP", 5, 17],
                    ["물리 공격력",6, 0],
                    ["마법 공격력",6, 7],
                    ["물리 저항력",7, 18],
                    ["마법 저항력",8, 16],
                    ["명중", 9, 7],
                    ["회피",10, 18],
                    ["행동 불가 시간 감소", 11, 16],
                    ["근접 대미지 감소", 12, 17],
                    ["원거리 대미지 감소", 13, 16.5],
                    ["냉기 대미지 감소", 14, 16.5],
                    ["보스 몬스터 공격 시 대미지 증가", 15, 7.7],
                    ["화염 대미지 감소", 15, 15.5],
                    ["암흑 대미지 감소", 16, 14.5],
                    ["처치 시 HP 회복", 16, 20],
                    ["신성 대미지 감소", 17, 13.5],
                    ["독 대미지 감소", 18, 16],
                    ["전격 대미지 감소", 19, 15]
                ].reduce((a,c)=>{
                    let [optionName, sortOrder, revealProbablity] = c;
                    a[optionName]=new AdditionalOption(optionName, sortOrder, revealProbablity);
                    return a;
                },{});

                console.log("추옵 :" , additionOptions);

                let sortedOrder_additionalOptions=[];
                for(let a in additionOptions){
                    sortedOrder_additionalOptions.push(additionOptions[a]);
                }
                sortedOrder_additionalOptions.sort((a,b)=>a?.order>b?.order);
                console.log("정렬된 옵션 순서: ", sortedOrder_additionalOptions);


                //정렬된 순서로 된 우선 순위 별 옵션 정보를 입력합니다.
                dom_ol_additionaloptions.forEach(element => {
                    let previousOption = undefined;
                    let dom_li = undefined;
                    sortedOrder_additionalOptions.forEach((e_option)=>{
                        let dom_p_optionName = document.createElement("p");
                        dom_p_optionName.innerText = new String(e_option.name);
                        if(previousOption?.order!=e_option?.order){
                            dom_li = document.createElement("li");
                            dom_li.appendChild(dom_p_optionName);
                            element.appendChild(dom_li);
                        }
                        else{
                            dom_li.appendChild(dom_p_optionName);
                        }
                        previousOption = e_option;
                    });
                });

                //단 한번만 뽑힐 수 있는 옵션 그룹 정보를 입력합니다.
                let onlyOneAdditionOptions=[
                    "STR",
                    "DEX",
                    "INT",
                    "LUK",
                    "물리 공격력",
                    "마법 공격력",
                    "명중",
                    "보스 몬스터 공격 시 대미지 증가"
                ];
                dom_ol_additionaloptions_onlyone.forEach(element=>{
                    onlyOneAdditionOptions.forEach((name_option)=>{
                        let dom_li = document.createElement("li");
                        let dom_p_optionName = document.createElement("p");
                        dom_p_optionName.innerText = new String(name_option);
                        dom_li.appendChild(dom_p_optionName);
                        element.appendChild(dom_li);
                    });
                });

                const prop_trials = 821;
                const pick_option_trials = 3;

                let optionRatioChecker = sortedOrder_additionalOptions.reduce((a,c)=>{
                    let name_additionalOption = c.name;
                    a[name_additionalOption]=((value, times)=>{
                        let ret_arr = [];
                        for(times=Math.abs(times); times > 0; times--) ret_arr.push(value);
                        return ret_arr;
                    })(0, pick_option_trials);
                    return a;
                }, {})

                console.log("옵션체크 객체 :", optionRatioChecker);

                let promise_getAdditionalOptionsResult = new Promise((resolve, reject)=>{
                    let prop_result=((sortedOrder_additionalOptions, picks = 0, trials=0)=>{
                    // 0. 결과값을 저장할 배열 만들기
                    let result_picked_additionalOptions=[];

                    // 0-1. 확률값 0 이하인 옵션 제거. (원래 배열에 영향을 끼치지 않음)
                    sortedOrder_additionalOptions = sortedOrder_additionalOptions.reduce((a,c)=> c.probablity > 0 ? a.concat([c]) : a, []);
                   
                    // 1. 반복 실행
                    for(let idx_trial = 0; idx_trial < trials ; idx_trial++){
                         // 2. 확률의 전체값 알아내기
                            let value_sumProbablity;
                            // 3. 뽑기 설정 초기화
                            let pickObject={
                                value_sumProbablity : sortedOrder_additionalOptions.reduce((a,c)=>a+c.probablity, 0),
                                optionProbablities_hash : sortedOrder_additionalOptions.reduce((a,c)=>{
                                    let current_probablity = c.probablity;
                                    if(a.length > 0) current_probablity += a[a.length-1];
                                    a.push(current_probablity);
                                    return a;
                                },[]),
                                pickgroup_additionalOptions : [...sortedOrder_additionalOptions],
                                pickgroup_onlyOneAdditionOptions : [...onlyOneAdditionOptions]
                            };
                            // 4. 뽑기 결과를 담을 결과 배열 리셋
                            let picked_additionalOptions = [];
                            // 5. 뽑기 실행
                            for(let idx_i=0; idx_i < picks ; idx_i++){
                                let picked_probablity = Math.random() * pickObject.value_sumProbablity; //랜덤확률값 뽑기
                                console.log("뽑힌 확률 : ", picked_probablity, "최대 확률 : ", pickObject.value_sumProbablity);
                                let picked_idx_additioalOption = pickObject.optionProbablities_hash.findIndex((e,i,a)=>(0<= picked_probablity && picked_probablity <= e ));
                                console.log("hash : ", pickObject.optionProbablities_hash);
                                // Note : Array.splice 메서드는 원래 배열에 영향을 끼친다.
                                function removeAdditionalOptionofPickgroup(e_idx){
                                    if(e_idx<0 || pickObject.pickgroup_additionalOptions.length <= e_idx) return undefined; // 아무 옵션도 배출하지 않는다
                                    let ret_additionalOption = pickObject.pickgroup_additionalOptions[e_idx];    //추가 옵션 뽑기 배열의 뽑고자 하는 인덱스의 추가 옵션을 지정한다.
                                    let _splited_right_hash = pickObject.optionProbablities_hash.slice(e_idx+1).map((x)=>x=x-ret_additionalOption.probablity);   //추가 옵션의 오른쪽 확률을 뺀 값을 반영한다.
                                    pickObject.optionProbablities_hash = pickObject.optionProbablities_hash.slice(0, e_idx).concat(_splited_right_hash);    //추가 옵션의 왼쪽 부분 + 추가 옵션의 확률 뺀 값을 반영한 배열 결합.
                                    pickObject.value_sumProbablity -= ret_additionalOption.probablity;   // 전체 확률에서 뽑은 옵션의 확률을 뺀다.
                                    
                                    //console.log("pickgroup : ", pickObject.pickgroup_additionalOptions);
                                    // 뽑은 추가 옵션을 추가 옵션 구성품에서 제거한다. 
                                    let _arr = pickObject.pickgroup_additionalOptions;
                                    pickObject.pickgroup_additionalOptions = _arr.slice(0,e_idx).concat(_arr.slice(e_idx+1));
                                    // 뽑은 옵션을 반환한다.
                                    return ret_additionalOption;
                                }

                                // 추가 옵션을 뽑으며 뽑은 구성품은 뽑기목록에서 제거한다.
                                let picked_additionalOption = removeAdditionalOptionofPickgroup(picked_idx_additioalOption);

                                // 단 한 번만 나오는 옵션이 존재하는 경우, 이후에는 1회용 옵션이 나오지 않도록 추가옵션 뽑기에서 삭제해버린다.
                                if(pickObject.pickgroup_onlyOneAdditionOptions.includes(picked_additionalOption?.name)){
                                    let idx_removes = (pickObject.pickgroup_onlyOneAdditionOptions.reduce((a,c)=>{
                                        let idx_remove = pickObject.pickgroup_additionalOptions.findIndex((e)=>e?.name===c);
                                        return idx_remove >= 0 ? a.concat([idx_remove]) : a;
                                    },[])).sort((a,b)=>a - b).reverse(); //반드시 내림차순으로 제거할 인덱스를 정해야 정렬해야 정상적으로 제거가 된다.
                                    //정렬 시 주의 : .sort()으로 그냥 사용 시 크기가 작은 순서대로 정렬하는 게 아닌, 앞자리가 0~9순으로 정렬되기 떄문에 반드시 (a,b)=>a-b 를 인자로 넣어줘야 한다.
                                    //console.log("제거될 항목 : ", idx_removes);
                                    idx_removes.forEach((e)=>removeAdditionalOptionofPickgroup(e));
                                }

                                // 뽑은 추가 옵션을 뽑기 목록에 추가한다. (꽝은 옵션 구성에서 제외)
                                console.log("뽑힌 옵션 :", picked_additionalOption);
                                if(picked_additionalOption !== undefined && picked_additionalOption !== null)picked_additionalOptions.push(picked_additionalOption);

                            }
                            result_picked_additionalOptions.push(picked_additionalOptions.sort((a,b)=>{
                                //console.log("a : ", a.order, " b:", b.order);
                                return a.order - b.order;
                            } ));
                            console.log(idx_trial,"번째","뽑기 결과 :", result_picked_additionalOptions[idx_trial]);
                            //뽑기 결과 집계
                            if(Array.isArray(result_picked_additionalOptions[idx_trial]))
                                result_picked_additionalOptions[idx_trial].forEach((e,i)=>(e !== undefined && e !== null) ? optionRatioChecker[e.name][i]++ : undefined);
                        }
                        
                        // 최종 : 결과값을 담은 2차원 배열 반환.
                        return result_picked_additionalOptions;
                    })(sortedOrder_additionalOptions, pick_option_trials, prop_trials);

                    console.log(prop_result);
                    console.log(optionRatioChecker);

                    resolve([prop_result, optionRatioChecker]);
                }).then((value_resolve)=>{
                    let [prop_result, optionRatioChecker] = [...value_resolve];

                    function object_to_two_dimen_array(target_object){
                        let ret_array = []; //master array;
                        for(let key in target_object){
                            let target_keyValue = target_object[key];
                            if(target_keyValue === undefined || target_keyValue === null);
                            else{
                                if(!Array.isArray(target_keyValue)) target_keyValue = [target_keyValue];
                                ret_array.push([key, ...target_keyValue]);
                            } 
                        }
                        return ret_array;
                    }

                    //2차원 배열을 table DOM 객채로 된 표로 변환시켜주는 함수
                    function two_dimen_array_to_table(target_array, value_fomula_func){
                        let packed_target_array = Array.from(target_array);
                        console.log(value_fomula_func);
                        if(typeof(value_fomula_func) == "function") packed_target_array = packed_target_array.map(element_row=>element_row.map(value_fomula_func));
                        let dom_table = document.createElement("table");
                        packed_target_array.forEach((element, idx_row) => {
                            if(Array.isArray(element)){
                                let dom_tr = document.createElement("tr");
                                element.forEach((element_column, idx_col)=>{
                                    let dom_td = document.createElement("td");
                                    dom_td.innerText = new String(element_column);
                                    dom_tr.appendChild(dom_td);
                                })
                                dom_table.appendChild(dom_tr);
                            }
                        });
                        console.log("hello, table,", dom_table);
                        return dom_table;
                    }

                    function range(n){
                        let ret_arr = [];
                        for(let i = 0 ; i <n ; i++) ret_arr.push(i);
                        return ret_arr
                    }
                    let arr_optionRatio_result = [["옵션 종류"].concat(range(pick_option_trials).map(x=>"위치"+new String(x+1))).concat(["합계"])].concat(   //머릿말 표식 달기
                        object_to_two_dimen_array(optionRatioChecker)   //객체를 2차원 배열로 바꾸기
                        .map((row)=>[...row, row.slice(1).reduce((a,c)=>a=a+c,0)])); //각 행의 끝에 각 행의 합 붙이기
                    console.log("옵션 배열", arr_optionRatio_result);
                    const result_div_table_className = "ms2-additionaloptions-probablity-test-result";
                    const result_div_table_additionalOptions_statistics_className = "ms2-additionaloptions-probablity-test-statistics-result";
                    Array.from(document.getElementsByClassName(result_div_table_className)).forEach(e=>e.appendChild(two_dimen_array_to_table(prop_result, (x)=>x.name)));
                    Array.from(document.getElementsByClassName(result_div_table_additionalOptions_statistics_className)).forEach(e=>e.appendChild(two_dimen_array_to_table(arr_optionRatio_result)));
                });
                

               
            </script>
            <br/>

            <!-- origin source -->
            <script type="text/javascript" src="ms2_character_attack_status.js"></script>
            <!-- source code of createTag function -->
            <script type="text/javascript" src="createTag.js"></script>
            <!-- source code of character inventory implementation -->
            <script type="text/javascript" src="ms2_character_inventory.js"></script>
            <!-- html tag maker -->
            <script type="text/javascript" src="ms2_damage_checker.js"></script>
            
        </div>
    </section>
</body>